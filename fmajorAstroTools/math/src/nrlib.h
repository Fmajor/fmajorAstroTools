/* This file was automatically generated.  Do not edit! */
void solveUseLU(int n,int N,double L[],double U[],const double y[],double r[]);
void blockLUdecomposition(int n,int N,double a[],double L[],double U[],int debug);
void variateDeconvolve(int ndata,int npad,const double x[],const double y[],const double sigma[],double result[],double kernel[],int debug);
void variateConvolve(int ndata,int npad,const double x[],const double y[],const double sigma[],double result[],double kernel[]);
void genBlocks(int ndata,const double x[],const double xcen[],int nTrace,double sigma[],int blocks[],int bMin[],int bMax[],int nBnads[],int debug);
int partition(double A[],int p,int r);
int randomInt(int p,int r);
int randomized_partition(double A[],int p,int r);
double randomized_select(double A[],int p,int r,int i);
double percentile(double A[],int n,double p);
int gaussianFitIter(int ndata,const double x[],const double y[],const double sig[],const double logA[],const double xcen[],const double xcenMin[],const double xcenMax[],const double sigma[],const double sigmaMin[],const double sigmaMax[],int nTrace,int nPoly,int fullreject[],double reject,double sigmal,int ignoreBadFit,double a[],double p[],int ia[],int maxiter,double gmod[],double bmod[],double chi2[],int bMin[],int bMax[],int niters[],double myMindchi2,int myFinishGoodCount,double myDlamda,int debug);
void findXLimits(int *xmin,int *xmax,const double *x,const double *xcen,int nTrace,int nx,const double *sigma,double sigmal);
void findBlocks(int *xmin,int *xmax,int *blocks,int *bMin,int *bMax,int **corMat,int nTrace,int *nBands);
void lastmrqcofGB(const double x[],const double y[],const double sig[],int ndata,double a[],int ia[],double goodSum[],int nTrace,int nPoly,double gmodArray[],double bmodArray[],double *chisq);
void dPoly(double x,double xMin,double xMax,double a[],double *y,double dyda[],int n);
void dGaussian(double x,double a[],double *y,double dyda[],double goodSum[],int tTrace,int subpixs,double subpixWidth);
double dmin(const double A[],int n);
double dmax(const double A[],int n);
void covsrt(double **covar,int ma,int ia[],int mfit);
int gaussj(double **a,int n,double **b,int m);
void mrqcofGB(const double x[],const double y[],const double sig[],int ndata,double a[],int ia[],double goodSum[],int nTrace,int nPoly,double **alpha,double beta[],double gmodArray[],double bmodArray[],double *chisq);
int mrqminGB(int ndata,const double x[],const double y[],const double sig[],const double xcenMin[],const double xcenMax[],const double sigmaMin[],const double sigmaMax[],double a[],int ia[],double goodSum[],int nTrace,int nPoly,double **covar,double **alpha,double gmod[],double bmod[],double reject,double *chisq,double *alamda);
void free_f3tensor(float ***t,long nrl,long nrh,long ncl,long nch,long ndl,long ndh);
void free_convert_matrix(float **b,long nrl,long nrh,long ncl,long nch);
void free_submatrix(float **b,long nrl,long nrh,long ncl,long nch);
void free_imatrix(int **m,long nrl,long nrh,long ncl,long nch);
void free_dmatrix(double **m,long nrl,long nrh,long ncl,long nch);
void free_matrix(float **m,long nrl,long nrh,long ncl,long nch);
void free_dvector(double *v,long nl,long nh);
void free_lvector(unsigned long *v,long nl,long nh);
void free_cvector(unsigned char *v,long nl,long nh);
void free_ivector(int *v,long nl,long nh);
void free_vector(float *v,long nl,long nh);
float ***f3tensor(long nrl,long nrh,long ncl,long nch,long ndl,long ndh);
float **convert_matrix(float *a,long nrl,long nrh,long ncl,long nch);
float **submatrix(float **a,long oldrl,long oldrh,long oldcl,long oldch,long newrl,long newcl);
int **imatrix(long nrl,long nrh,long ncl,long nch);
double **dmatrix(long nrl,long nrh,long ncl,long nch);
float **matrix(long nrl,long nrh,long ncl,long nch);
double *dvector(long nl,long nh);
unsigned long *lvector(long nl,long nh);
unsigned char *cvector(long nl,long nh);
int *ivector(long nl,long nh);
float *vector(long nl,long nh);
void nrerror(char error_text[]);
